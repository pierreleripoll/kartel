import{l as d,m as k,i as P,p as R,q as L,s as N,v as x,x as j,y as l,z as S,A as _,P as c,B as h,C as y,D as w,E as A,S as O,F as v,G as T,L as B}from"./DfYcYHnK.js";const E=d({name:"LayoutLoader",inheritAttrs:!1,props:{name:String,layoutProps:Object},setup(t,s){return()=>y(l[t.name],t.layoutProps,s.slots)}}),C={name:{type:[String,Boolean,Object],default:null},fallback:{type:[String,Object],default:null}},F=d({name:"NuxtLayout",inheritAttrs:!1,props:C,setup(t,s){const a=k(),u=P(c),e=!u||u===R()?L():u,o=N(()=>{let n=h(t.name)??(e==null?void 0:e.meta.layout)??"default";return n&&!(n in l)&&t.fallback&&(n=h(t.fallback)),n}),i=x();s.expose({layoutRef:i});const r=a.deferHydration();if(a.isHydrating){const n=a.hooks.hookOnce("app:error",r);j().beforeEach(n)}let f;return()=>{const n=o.value&&o.value in l,p=(e==null?void 0:e.meta.layoutTransition)??S,b=f;return f=o.value,_(n&&p,{default:()=>y(O,{suspensible:!0,onResolve:()=>{A(r)}},{default:()=>y(H,{layoutProps:w(s.attrs,{ref:i}),key:o.value||void 0,name:o.value,shouldProvide:!t.name,isRenderingNewLayout:m=>m!==b&&m===o.value,hasTransition:!!p},s.slots)})}).default()}}}),H=d({name:"NuxtLayoutProvider",inheritAttrs:!1,props:{name:{type:[String,Boolean]},layoutProps:{type:Object},hasTransition:{type:Boolean},shouldProvide:{type:Boolean},isRenderingNewLayout:{type:Function,required:!0}},setup(t,s){const a=t.name;t.shouldProvide&&v(B,{isCurrent:e=>a===(e.meta.layout??"default")});const u=P(c);if(u&&u===R()){const e=L(),o={};for(const i in e){const r=i;Object.defineProperty(o,r,{enumerable:!0,get:()=>t.isRenderingNewLayout(t.name)?e[r]:u[r]})}v(c,T(o))}return()=>{var e,o;return!a||typeof a=="string"&&!(a in l)?(o=(e=s.slots).default)==null?void 0:o.call(e):y(E,{key:a,layoutProps:t.layoutProps,name:a},s.slots)}}});export{F as _};
